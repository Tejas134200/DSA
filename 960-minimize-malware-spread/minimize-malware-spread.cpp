class Solution {
public:
    vector<int> par, rank;

    int find(int x){
        if(par[x] != x) par[x] = find(par[x]);
        return par[x];
    }

    void unite(int x, int y){
        int px = find(x);
        int py = find(y);
        if(px == py) return;

        if(rank[px] < rank[py]) par[px] = py;
        else if(rank[py] < rank[px]) par[py] = px;
        else{
            par[px] = py;
            rank[py]++;
        }
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        par.resize(n);
        rank.resize(n, 0);

        for(int i = 0; i < n; i++) par[i] = i;

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                if(i != j && graph[i][j]) unite(i, j);
            }
        }

        unordered_map<int,int> m;
        vector<vector<int>> mya(n, vector<int>(3));

        for(int i = 0; i < n; i++){
            int p = find(i);
            mya[i][0] = p;
            m[p]++;
        }

        for(int i = 0; i < n; i++){
            mya[i][1] = m[mya[i][0]];
        }

        unordered_map<int,int> mm;
        for(int i : initial){
            mm[mya[i][0]]++;
        }

        for(int i = 0; i < n; i++){
            mya[i][2] = mm[mya[i][0]];
        }

        int ans = INT_MAX;
int maxi = 0;

for(int i : initial){
    if(mya[i][2] == 1){              
        int vachushakto = mya[i][1];
        if(vachushakto > maxi){
            maxi = vachushakto;
            ans = i;
        } else if(vachushakto == maxi){
            ans = min(ans, i);
        }
    }
}

if(ans == INT_MAX){
    ans = *min_element(initial.begin(), initial.end());
}

return ans;

    }
};
